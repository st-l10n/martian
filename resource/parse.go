// Package resource implements utilities to generate po-files from
// language files and back.
package resource

import (
	"errors"
	"fmt"
	"io"
	"sort"
	"strings"

	"github.com/leonelquinteros/gotext"
	"github.com/st-l10n/etree"
)

type Entry struct {
	File              string `json:"file"` // without extension
	TranslatorComment string `json:"translator_comment,omitempty"`
	Reference         string `json:"reference,omitempty"`
	ID                string `json:"id"`
	Str               string `json:"str"`
	Context           string `json:"context,omitempty"`
}

type Entries []Entry

func (e Entries) TranslatedCount() int {
	var count int
	for _, entry := range e {
		if entry.Str == "" {
			continue
		}
		count++
	}
	return count
}

func (e Entries) Files() []string {
	m := make(map[string]bool)
	for _, entry := range e {
		m[entry.File] = true
	}
	files := make([]string, 0, len(m))
	for k := range m {
		files = append(files, k)
	}
	sort.Strings(files)
	return files
}

func (e Entries) WriteTemplateFile(file string, w io.Writer) error {
	_, err := fmt.Fprintln(w, "# Stationeers template translation file generated by martian")
	if err != nil {
		return err
	}
	for _, entry := range e {
		if entry.File != file {
			continue
		}
		entry.Str = ""
		if err = entry.WriteTo(w); err != nil {
			return err
		}
	}
	return nil
}

func (e Entries) WriteFile(file string, w io.Writer) error {
	_, err := fmt.Fprintln(w, "# Stationeers translation file generated by martian")
	if err != nil {
		return err
	}
	for _, entry := range e {
		if entry.File != file {
			continue
		}
		if err = entry.WriteTo(w); err != nil {
			return err
		}
	}
	return nil
}

func (e Entries) Len() int {
	return len(e)
}

func (e Entries) Less(i, j int) bool {
	a, b := e[i], e[j]
	for _, s := range []struct {
		aStr, bStr string
	}{
		{a.File, b.File},
		{a.Context, b.Context},
		{a.ID, b.ID},
		{a.Reference, b.Reference},
		{a.TranslatorComment, b.TranslatorComment},
	} {
		if strings.Compare(s.aStr, s.bStr) < 0 {
			return true
		} else {
			return false
		}
	}
	return false
}

func (e Entries) Swap(i, j int) {
	e[i], e[j] = e[j], e[i]
}

func (e Entry) WriteTo(w io.Writer) error {
	fmt.Fprint(w, "\n")
	if len(e.TranslatorComment) > 0 {
		fmt.Fprintf(w, "# %s\n", e.TranslatorComment)
	}
	if len(e.Reference) > 0 {
		fmt.Fprintf(w, "#: %s\n", e.Reference)
	}
	if len(e.Context) > 0 {
		fmt.Fprintf(w, "msgctxt %q\n", e.Context)
	}
	fmt.Fprintf(w, "msgid %q\n", e.ID)
	fmt.Fprintf(w, "msgstr %q\n", e.Str)
	return nil
}

// reference {KEY:InventorySelect}
type reference struct {
	Type string // like "Key"
	Name string // like "InventorySelect"
}

func parseReferences(raw string) []reference {
	ref := make([]reference, 0, 10)
	for {
		startIndex := strings.Index(raw, "{")
		if startIndex < 0 {
			break
		}
		raw = raw[startIndex:]
		endIndex := strings.Index(raw, "}")
		if endIndex < 0 {
			break
		}
		kv := strings.SplitN(raw[:endIndex-1], ":", 2)
		if len(kv) < 2 {
			break
		}
		ref = append(ref, reference{
			Name: kv[0],
			Type: kv[1],
		})
		raw = raw[endIndex+1:]
	}
	return ref
}

type tip struct {
	raw           string
	translation   string
	refs          []reference
	codeReference string
}

func (t tip) equal(b []reference) bool {
	if len(b) != len(t.refs) {
		return false
	}
	for i, r := range b {
		if t.refs[i] != r {
			return false
		}
	}
	return true
}

func genTips(eng, d *etree.Document) (Entries, error) {
	var tips []tip
	for _, part := range eng.SelectElement("Language").ChildElements() {
		switch part.Tag {
		case "Name", "Code", "Font":
			continue
		}
		for i, c := range part.ChildElements() {
			dPath := c.GetPath() + fmt.Sprintf("[%d]", i)
			tips = append(tips, tip{
				codeReference: dPath,
				raw:           c.Text(),
				refs:          parseReferences(c.Text()),
			})
		}
	}
	if d != nil && d.SelectElement("Language") != nil {
		for _, part := range d.SelectElement("Language").ChildElements() {
			switch part.Tag {
			case "Name", "Code", "Font":
				continue
			}
			for _, c := range part.ChildElements() {
				raw := c.Text()
				refs := parseReferences(raw)
				for i, tip := range tips {
					if tip.equal(refs) {
						tip.translation = raw
						tips[i] = tip
						break
					}
				}
			}
		}
	}
	var entries Entries
	for _, tip := range tips {
		entries = append(entries, Entry{
			File:      "Tips",
			Reference: tip.codeReference,
			ID:        tip.raw,
			Str:       tip.translation,
		})
	}
	sort.Sort(entries)
	return entries, nil
}

// Gen generates .po entry list from original xml, trying to apply translations
// from translated xml.
func Gen(original, translated []byte) (Entries, error) {
	var entries Entries
	eng := etree.NewDocument()
	if err := eng.ReadFromBytes(original); err != nil {
		return nil, err
	}
	d := etree.NewDocument()
	if len(translated) > 0 {
		if err := d.ReadFromBytes(translated); err != nil {
			return nil, err
		}
	}
	l := eng.SelectElement("Language")
	if l == nil {
		return nil, errors.New("no language elem")
	}
	g := l.SelectElement("GameTip")
	if g != nil && len(g.Child) != 0 {
		return genTips(eng, d)
	}
	for _, part := range l.ChildElements() {
		switch part.Tag {
		case "Name", "Code", "Font":
			continue
		}
		for _, c := range part.ChildElements() {
			elemKey := c.SelectElement("Key").Text()
			dPath := c.GetPath() + "[Key='" + elemKey + "']"
			dElem := d.FindElement(dPath)
			for _, elemPart := range c.ChildElements() {
				switch elemPart.Tag {
				case "Key":
					continue
				}
				p := elemPart.GetRelativePath(c)
				var dPart *etree.Element
				entry := Entry{
					Context:   part.Tag,
					File:      part.Tag,
					ID:        elemKey,
					Reference: dPath,
				}
				if dElem != nil {
					dPart = dElem.FindElement(p)
				}
				if dPart != nil {
					entry.Str = dPart.Text()
					if entry.Str == "" {
						entry.Str = Blank
					}
				}
				if elemPart.Tag != "Value" {
					entry.ID += "." + elemPart.Tag
				}
				entries = append(entries, entry)
			}
		}
	}
	sort.Sort(entries)
	return entries, nil
}

type Options struct {
	Original    []byte   // "xml"
	Translation [][]byte // ".po" files
	Code        string
	Name        string
	Font        string
}

const Blank = "{BLANK}"

// Bake generates new translation file.
// Original is original english xml file, translation is po-formatted file.
// Returns new xml.
func Bake(o Options) ([]byte, error) {
	if o.Code == "" {
		return nil, errors.New("no code provided")
	}
	translations, original := o.Translation, o.Original
	t := &gotext.Po{}
	for _, translation := range translations {
		t.Parse(translation)
	}
	eng := etree.NewDocument()
	if err := eng.ReadFromBytes(original); err != nil {
		return original, fmt.Errorf("failed to parse original: %v", err)
	}
	d := eng.Copy()
	e := d.SelectElement("Language")
	name := e.FindElement("Name")
	if name != nil {
		name.SetText(o.Name)
	}
	if o.Name == "" && name != nil {
		e.RemoveChild(name)
	}
	e.FindElement("Code").SetText(o.Code)
	f := e.FindElement("Font")
	if len(o.Font) > 0 {
		if f == nil {
			f = e.CreateElement("Font")
		}
		f.SetText(o.Font)
	} else if f != nil {
		e.RemoveChild(f)
	}
	for _, part := range e.ChildElements() {
		switch part.Tag {
		case "Name", "Code", "Font":
			continue
		}
		for _, e := range part.ChildElements() {
			k := e.SelectElement("Key")
			if k == nil {
				// Tips.
				translated := t.Get(e.Text())
				e.SetText(translated)
				continue
			}
			elemKey := k.Text()
			engPath := e.GetPath() + "[Key='" + elemKey + "']"
			engElem := eng.FindElement(engPath)
			if engElem == nil {
				continue
			}
			for _, elemPart := range e.ChildElements() {
				switch elemPart.Tag {
				case "Key":
					continue
				}
				p := elemPart.GetRelativePath(e)
				engPart := engElem.FindElement(p)
				engText := engPart.Text()
				id := elemKey
				if elemPart.Tag != "Value" {
					id += "." + elemPart.Tag
				}
				translated := t.GetC(id, part.Tag)
				elemPart.SetText(translated)
				if translated == "" {
					translated = engText
				}
				if translated == Blank {
					for _, child := range elemPart.Child {
						elemPart.RemoveChild(child)
					}
				}
			}
		}
	}
	d.WriteSettings.WhitespaceEndTags = true
	return d.WriteToBytes()
}
